"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reciprocal = exports.avg = exports.half = exports.abs = exports.max = exports.min = exports.sub2 = exports.sub1 = exports.add1 = exports.triple = exports.double = exports.sumOfCubes = exports.sumOfSquares = exports.cube = exports.sqr = void 0;
const NumericalComputationPredicates_1 = require("./NumericalComputationPredicates");
/**
 * Algory
 *
 * Copyright (c) Anurag Muthyam <anu.drumcoder@gmail.com>
 * https://github.com/aryaghan-mutum
 *
 */
const numerPred = require('.//NumericalComputationPredicates');
const err = require('../TypeViolation');
const curry = require('curry');
/**
 * @remarks Square a number
 *  F(n) => (* n n)
 *
 * @param n - An input number
 * @returns Squared number
 */
exports.sqr = curry((n) => {
    return n * n;
});
/**
 * @remarks Cube a number
 * F(n) => (* n n n)
 *
 * @param n - An input number
 * @returns Cubed number
 */
exports.cube = curry((n) => {
    return exports.sqr(n) * n;
});
/**
 * @remarks Square two numbers and sum the returned values
 * F(n) => (+ (square x) (square y))
 */
exports.sumOfSquares = curry(
/**
 * @param x
 * @param y
 * @returns - Sum of Squares
 */
(x, y) => {
    return exports.sqr(x) + exports.sqr(y);
});
/**
 * @remarks Cube two numbers and sum the returned values
 * F(n) => (+ (cube x) (cube y))
 */
exports.sumOfCubes = curry(
/**
 * @param x
 * @param y
 * @returns Sum of Cubes
 */
(x, y) => {
    return exports.cube(x) + exports.cube(y);
});
/**
 * @remarks Double a number
 * F(n) => (* n 2) or F(n) => (+ n n)
 *
 * @param n - An input number
 * @returns Doubled number
 */
exports.double = curry((n) => {
    return n * 2;
});
/**
 * @remarks Triple a number.
 * F(n) => (* n 3) or F(n) => (+ n n n)
 */
exports.triple = curry(
/**
 * @param n
 * @returns
 */
(n) => {
    err.numberTypeViolationError(n);
    return n * 3;
});
/**
 * @remarks Add a number
 * F(n) => (+ n 1)
 */
exports.add1 = curry(
/**
 * @param n
 * @returns
 */
(n) => {
    err.numberTypeViolationError(n);
    return n + 1;
});
/**
 * @remarks Subtract a number
 * F(n) => (- n 1)
 */
exports.sub1 = curry(
/**
 * @param n
 * @returns
 */
(n) => {
    err.numberTypeViolationError(n);
    return n - 1;
});
/**
 * @remarks Subtract two numbers
 * F(n) => (- n 2)
 */
exports.sub2 = curry(
/**
 * @param n
 * @returns
 */
(n) => {
    err.numberTypeViolationError(n);
    return n - 2;
});
/**
 * @remarks Get the minimum number between two numbers
 * F(x, y) => (< a b) ? a : b
 */
exports.min = curry(
/**
 * @param a
 * @param b
 * @returns
 */
(a, b) => {
    return a < b ? a : b;
});
/**
 * @remarks Get the maximum number between two numbers
 * F(x, y) => (> a b) ? a : b
 */
exports.max = curry(
/**
 * @param a
 * @param b
 * @returns
 */
(a, b) => {
    return a > b ? a : b;
});
/**
 * @remarks //TODO
 * @param base
 * @param n
 */
// export const pow = curry(
// (base: number, n: number): number => {
//     return numerPred.isZero(n) ? 1 : base + pow(base, n - 1)
// })
/**
 * @remarks Get an Absolute/modulus a number
 * F(n) => |n|
 */
exports.abs = curry(
/**
 * @param n
 * @returns
 */
(n) => {
    err.numberTypeViolationError(n);
    return numerPred.isPositive(n) ? n : -(n);
});
/**
 * @remarks
 * F(n) => (/ n 2)
 */
exports.half = curry(
/**
 * @param n
 * @returns
 */
(n) => {
    return n / 2;
});
/**
 * @remarks An Average of two numbers
 * F(x, y) => (/ x y)
 */
exports.avg = curry(
/**
 * @param x - An input first argument number
 * @param y - An input second argument number
 * @return An average of two numbers
 */
(x, y) => {
    return x + y / 2;
});
/**
 * @remarks Reciprocal/Inverse a number
 * F(n) => (/ 1 n)
 */
exports.reciprocal = curry(
/**
 * @param n - An input number
 * @returns Reciprocal number
 */
(n) => {
    if (NumericalComputationPredicates_1.isZero(n)) {
        throw new Error('Reciprocal/Inverse of 0 is undefined');
    }
    else {
        return 1 / n;
    }
});
/**
 *
 * @remarks FIXME:
 *
 */
// export const combination = curry(
// (n: number, m: number): number => {
//     if (numerPred.isZero(m) || (m == n)) {
//         return 1
//     } else {
//         return combination(sub1(n), m) + combination(sub1(n), sub1(m))
//     }
// })
//# sourceMappingURL=NumericalComputation.js.map